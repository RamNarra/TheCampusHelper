rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- HELPER FUNCTIONS ---

    function isAuthenticated() {
      return request.auth != null;
    }

    function isBootstrapAdmin() {
      // Bootstrap path for the very first admin: either a custom claim, or a strict allowlist.
      // NOTE: Update this allowlist for your project.
      return isAuthenticated() && (
        // IMPORTANT: Do not use email allowlists in deployed rules. Use custom claims only.
        request.auth.token.admin == true
      );
    }

    // --- VALIDATION HELPERS ---

    function isHttpsUrl(s) {
      return s is string
        && s.size() > 8
        && s.size() < 2000
        && s.matches('^https://.*');
    }

    function isSafeDisplayName(s) {
      return (s == null) || (s is string && s.size() >= 0 && s.size() <= 80);
    }

    function isSafePhotoUrl(s) {
      return (s == null) || (s is string && s.size() > 0 && s.size() <= 2048 && s.matches('^https?://.*'));
    }

    function isNonNegInt(n, max) {
      return n is int && n >= 0 && n <= max;
    }

    function isValidPresenceWrite(newData, currentData) {
      // Allow only known keys; for updates, only allow changes to known keys.
      let allowed = ['state', 'lastSeen', 'updatedAt', 'displayName', 'photoURL', 'uid'];
      let changedOk = newData.diff(currentData).changedKeys().hasOnly(allowed);
      let keysOk = newData.keys().hasOnly(allowed);

      let stateOk = !('state' in newData)
        || newData.state == 'online'
        || newData.state == 'idle'
        || newData.state == 'offline';

      let lastSeenOk = !('lastSeen' in newData) || newData.lastSeen == request.time;
      let updatedAtOk = !('updatedAt' in newData) || newData.updatedAt == request.time;
      let nameOk = !('displayName' in newData) || isSafeDisplayName(newData.displayName);
      let photoOk = !('photoURL' in newData) || isSafePhotoUrl(newData.photoURL);
      let uidOk = !('uid' in newData) || newData.uid == request.auth.uid;

      return keysOk && changedOk && stateOk && lastSeenOk && updatedAtOk && nameOk && photoOk && uidOk;
    }

    function isValidLeaderboardWrite(newData, currentData, userId) {
      // Stored fields are derived from the user's own profile.
      // We can't fully prevent cheating without server-side XP awarding, but we can:
      // - bound values
      // - prevent arbitrary keys
      // - enforce lastUpdated is server-time
      let allowed = ['displayName', 'photoURL', 'xp', 'level', 'lastUpdated'];
      let keysOk = newData.keys().hasOnly(allowed);
      let changedOk = newData.diff(currentData).changedKeys().hasOnly(allowed);

      let nameOk = !('displayName' in newData) || isSafeDisplayName(newData.displayName);
      let photoOk = !('photoURL' in newData) || isSafePhotoUrl(newData.photoURL);
      let xpOk = !('xp' in newData) || isNonNegInt(newData.xp, 1000000);
      let levelOk = !('level' in newData) || (newData.level is int && newData.level >= 1 && newData.level <= 1000);
      let updatedOk = ('lastUpdated' in newData) && newData.lastUpdated == request.time;

      return isOwner(userId) && keysOk && changedOk && nameOk && photoOk && xpOk && levelOk && updatedOk;
    }

    function isValidMessageCreate(data, groupId) {
      // Allow text/file/audio messages with conservative limits.
      return data.keys().hasOnly([
        'studyGroupId',
        'senderId',
        'senderName',
        'senderPhotoURL',
        'content',
        'kind',
        'fileUrl',
        'fileName',
        'mimeType',
        'timestamp',
        'edited',
        'editedAt'
      ])
      && ('studyGroupId' in data) && data.studyGroupId == groupId
      && ('senderId' in data) && data.senderId == request.auth.uid
      && ('senderName' in data) && data.senderName is string && data.senderName.size() > 0 && data.senderName.size() <= 80
      && (!('senderPhotoURL' in data) || (
        data.senderPhotoURL is string
        && data.senderPhotoURL.size() > 0
        && data.senderPhotoURL.size() <= 2048
        && data.senderPhotoURL.matches('^https?://.*')
      ))
      && ('content' in data) && data.content is string && data.content.size() > 0 && data.content.size() <= 10000
      && (!('kind' in data) || data.kind == 'text' || data.kind == 'file' || data.kind == 'audio')
      && (!('fileUrl' in data) || isHttpsUrl(data.fileUrl))
      && (!('fileName' in data) || (data.fileName is string && data.fileName.size() > 0 && data.fileName.size() <= 200))
      && (!('mimeType' in data) || (data.mimeType is string && data.mimeType.size() > 0 && data.mimeType.size() <= 150))
      && ('timestamp' in data) && data.timestamp == request.time
      && (!('edited' in data) || data.edited is bool)
      && (!('editedAt' in data) || data.editedAt == request.time);
    }

    function isValidMessageUpdate(newData, currentData) {
      // Only allow editing content and edit markers.
      let changed = newData.diff(currentData).changedKeys();
      let changedOk = changed.hasOnly(['content', 'edited', 'editedAt']);
      let senderImmutable = newData.senderId == currentData.senderId;
      let tsImmutable = newData.timestamp == currentData.timestamp;
      let contentOk = newData.content is string && newData.content.size() > 0 && newData.content.size() <= 10000;
      let editedOk = ('edited' in newData) && newData.edited == true;
      let editedAtOk = ('editedAt' in newData) && newData.editedAt == request.time;
      return changedOk && senderImmutable && tsImmutable && contentOk && editedOk && editedAtOk;
    }

    function isValidNoteCreate(data, groupId) {
      let allowed = ['studyGroupId', 'title', 'content', 'lastEditedBy', 'lastEditedByName', 'lastEditedAt', 'createdBy', 'createdAt'];
      let keysOk = data.keys().hasOnly(allowed);
      let groupOk = ('studyGroupId' in data) && data.studyGroupId == groupId;
      let titleOk = ('title' in data) && data.title is string && data.title.size() > 0 && data.title.size() <= 200;
      let contentOk = ('content' in data) && data.content is string && data.content.size() >= 0 && data.content.size() <= 50000;
      let createdByOk = ('createdBy' in data) && data.createdBy == request.auth.uid;
      // createdAt/lastEditedAt may be client-provided; prefer server-time.
      let createdAtOk = !('createdAt' in data) || data.createdAt == request.time;
      let editedByOk = !('lastEditedBy' in data) || data.lastEditedBy == request.auth.uid;
      let editedAtOk = !('lastEditedAt' in data) || data.lastEditedAt == request.time;
      let editorNameOk = !('lastEditedByName' in data) || (data.lastEditedByName is string && data.lastEditedByName.size() > 0 && data.lastEditedByName.size() <= 80);
      return keysOk && groupOk && titleOk && contentOk && createdByOk && createdAtOk && editedByOk && editedAtOk && editorNameOk;
    }

    function isValidNoteUpdate(newData, currentData) {
      let changed = newData.diff(currentData).changedKeys();
      let changedOk = changed.hasOnly(['content', 'lastEditedBy', 'lastEditedByName', 'lastEditedAt']);
      let createdImmutable = newData.createdBy == currentData.createdBy && newData.createdAt == currentData.createdAt;
      let titleImmutable = newData.title == currentData.title;
      let editorOk = ('lastEditedBy' in newData) && newData.lastEditedBy == request.auth.uid;
      let editorNameOk = ('lastEditedByName' in newData) && newData.lastEditedByName is string && newData.lastEditedByName.size() > 0 && newData.lastEditedByName.size() <= 80;
      let editedAtOk = ('lastEditedAt' in newData) && newData.lastEditedAt == request.time;
      let contentOk = ('content' in newData) && newData.content is string && newData.content.size() >= 0 && newData.content.size() <= 50000;
      return changedOk && createdImmutable && titleImmutable && editorOk && editorNameOk && editedAtOk && contentOk;
    }

    function myUserDoc() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function isCollegeEmailMatchesBranch() {
      let b = myUserDoc().branch;
      let e = myUserDoc().collegeEmail;
      return (b == 'CSE' && e.matches('^[A-Za-z0-9]{6,16}@cse\\.sreenidhi\\.edu\\.in$'))
        || (b == 'IT' && e.matches('^[A-Za-z0-9]{6,16}@it\\.sreenidhi\\.edu\\.in$'))
        || (b == 'DS' && e.matches('^[A-Za-z0-9]{6,16}@ds\\.sreenidhi\\.edu\\.in$'))
        || (b == 'AIML' && e.matches('^[A-Za-z0-9]{6,16}@aiml\\.sreenidhi\\.edu\\.in$'))
        || (b == 'CYS' && e.matches('^[A-Za-z0-9]{6,16}@cs\\.sreenidhi\\.edu\\.in$'))
        || (b == 'ECE' && e.matches('^[A-Za-z0-9]{6,16}@ece\\.sreenidhi\\.edu\\.in$'))
        || (b == 'EEE' && e.matches('^[A-Za-z0-9]{6,16}@eee\\.sreenidhi\\.edu\\.in$'))
        || (b == 'MECH' && e.matches('^[A-Za-z0-9]{6,16}@me\\.sreenidhi\\.edu\\.in$'))
        || (b == 'CIVIL' && e.matches('^[A-Za-z0-9]{6,16}@ce\\.sreenidhi\\.edu\\.in$'));
    }

    function isProfileComplete() {
      // Keep conservative: if missing/invalid, treat as incomplete.
      return isAuthenticated()
        && exists(/databases/$(database)/documents/users/$(request.auth.uid))
        && ('displayName' in myUserDoc())
        && (myUserDoc().displayName is string)
        && (myUserDoc().displayName.size() > 0)
        && (myUserDoc().displayName.size() <= 80)
        && ('collegeEmail' in myUserDoc())
        && (myUserDoc().collegeEmail is string)
        && (myUserDoc().collegeEmail.size() > 3)
        && (myUserDoc().collegeEmail.size() <= 120)
        && ('dateOfBirth' in myUserDoc())
        && (myUserDoc().dateOfBirth is string)
        && (myUserDoc().dateOfBirth.size() > 0)
        && (myUserDoc().dateOfBirth.size() <= 16)
        && ('branch' in myUserDoc())
        && (myUserDoc().branch is string)
        && (myUserDoc().branch.size() > 0)
        && (myUserDoc().branch.size() <= 20)
        && isCollegeEmailMatchesBranch()
        && ('section' in myUserDoc())
        && (myUserDoc().section is string)
        && (myUserDoc().section.size() > 0)
        && (myUserDoc().section.size() <= 10);
    }

    function phase1ServerlessOnly() {
      // Single runtime toggle: /config/phase1 { serverlessOnly: true|false }
      // - Readable by clients (non-sensitive)
      // - Used by rules to gate legacy direct-write paths
      return exists(/databases/$(database)/documents/config/phase1)
        && get(/databases/$(database)/documents/config/phase1).data.serverlessOnly == true;
    }

    function myRole() {
      // Normalize legacy roles to new platform roles.
      // Default is 'student' (never 'admin').
      let r = (isAuthenticated() && exists(/databases/$(database)/documents/users/$(request.auth.uid)) && ('role' in myUserDoc()))
        ? myUserDoc().role
        : 'student';

      return r == 'user' ? 'student'
        : r == 'mod' ? 'moderator'
        : r;
    }

    function isAdmin() {
      return isAuthenticated() && (isBootstrapAdmin() || myRole() == 'admin' || myRole() == 'super_admin');
    }

    function isStaff() {
      return isAuthenticated() && (isAdmin() || myRole() == 'moderator');
    }

    function isPlatformInstructor() {
      return isAuthenticated() && myRole() == 'instructor';
    }

    function isMod() {
      return isAuthenticated() && (isAdmin() || myRole() == 'moderator');
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function myYear() {
      return isAuthenticated() && exists(/databases/$(database)/documents/users/$(request.auth.uid)) && ('year' in myUserDoc())
        ? myUserDoc().year
        : null;
    }

    function isAllowedYear(data) {
      return !('visibleToYears' in data)
        || (myYear() != null && myYear() in data.visibleToYears);
    }

    // --- COURSE-SCOPED ABAC HELPERS ---
    function isActiveEnrollment(courseId) {
      return isAuthenticated()
        && exists(/databases/$(database)/documents/courses/$(courseId)/enrollments/$(request.auth.uid))
        && get(/databases/$(database)/documents/courses/$(courseId)/enrollments/$(request.auth.uid)).data.status == 'active';
    }

    function isInstructor(courseId) {
      return isAuthenticated()
        && exists(/databases/$(database)/documents/courses/$(courseId)/enrollments/$(request.auth.uid))
        && get(/databases/$(database)/documents/courses/$(courseId)/enrollments/$(request.auth.uid)).data.status == 'active'
        && get(/databases/$(database)/documents/courses/$(courseId)/enrollments/$(request.auth.uid)).data.role == 'instructor';
    }

    // Validates resource structure (allows extra keys)
    function isValidResource(data) {
      return data.keys().hasAll(['title', 'subject', 'type', 'downloadUrl', 'ownerId', 'status', 'createdAt', 'updatedAt'])
             && data.title is string && data.title.size() > 3 && data.title.size() < 200
             && data.subject is string && data.subject.size() > 0 && data.subject.size() < 200
             && data.type is string && data.type.size() > 0 && data.type.size() < 50
             // System-defined, non-editable categories (no custom folders).
             && (data.type == 'PPT' || data.type == 'MidPaper' || data.type == 'PYQ' || data.type == 'ImpQ')
             && data.downloadUrl is string && data.downloadUrl.size() > 5 && data.downloadUrl.size() < 2000
             && data.ownerId is string
             // Legacy unit-based categorization is no longer allowed.
             && !('unit' in data)
             && (data.status == 'pending' || data.status == 'approved' || data.status == 'rejected');
    }

    function canSetModeratedStatus(data) {
      // Users can only submit pending resources.
      // Mods/Admins can approve/reject.
      return data.status == 'pending' || ((data.status == 'approved' || data.status == 'rejected') && isMod());
    }

    // Prevents privilege escalation on user profiles
    function roleIsAllowedOnCreate(data) {
      // Normal users may only create with role 'student' (or omit role).
      // Bootstrap admin may create their own profile with role 'admin' (back-compat).
      return !("role" in data)
        || data.role == 'student'
        || data.role == 'user'
        || (data.role == 'admin' && isBootstrapAdmin())
        || (data.role == 'super_admin' && isBootstrapAdmin());
    }

    function roleIsSafeOnOwnerUpdate(newData, currentData) {
      // Owners cannot change role/disabled.
      // Back-compat: if role is missing, owner may set role='student' (or legacy 'user') only.
      let roleOk = !("role" in newData)
        || ("role" in currentData && newData.role == currentData.role)
        || (!("role" in currentData) && (newData.role == 'student' || newData.role == 'user'));

      let disabledOk = !("disabled" in newData)
        || ("disabled" in currentData && newData.disabled == currentData.disabled);

      return roleOk && disabledOk;
    }

    // --- COLLECTION RULES ---

    // USERS COLLECTION
    match /users/{userId} {
      // Owner can read their profile; staff can read for moderation/admin.
      allow read: if isOwner(userId) || isMod();

      allow create: if isOwner(userId)
                    && roleIsAllowedOnCreate(request.resource.data);

      // Owner can update their own profile (no privilege escalation).
      allow update: if (
                      isOwner(userId)
                      && roleIsSafeOnOwnerUpdate(request.resource.data, resource.data)
                    )
                    || (
                      // Staff can update user docs EXCEPT privileged fields.
                      // Privileged changes must go through server endpoints (audited).
                      isAdmin()
                      && !("role" in request.resource.data)
                      && !("disabled" in request.resource.data)
                    );

      allow delete: if isAdmin();
    }

    // PRESENCE (real-time online/idle/offline)
    // Public to authenticated users only; only the owner can write their own doc.
    match /presence/{userId} {
      allow read: if isAuthenticated();
      allow create: if isOwner(userId) && isValidPresenceWrite(request.resource.data, {});
      allow update: if isOwner(userId) && isValidPresenceWrite(request.resource.data, resource.data);
      allow delete: if isOwner(userId) || isAdmin();
    }

    // STUDY GROUP REQUESTS (pending admin approval)
    match /studyGroupRequests/{requestId} {
      allow read: if isAdmin() || (isAuthenticated() && resource.data.requestedBy == request.auth.uid);

      allow create: if isAuthenticated()
                    && isProfileComplete()
                    && request.resource.data.requestedBy == request.auth.uid
                    && request.resource.data.status == 'pending'
                    && request.resource.data.createdAt == request.time;

      // Admin reviews (approve/reject)
      allow update: if isAdmin();

      // Owner can withdraw their request; admin can clean up.
      allow delete: if isAdmin() || (isAuthenticated() && resource.data.requestedBy == request.auth.uid);
    }

    // --- COURSES / ENROLLMENTS (FOUNDATION) ---
    match /courses/{courseId} {
      allow read: if isStaff() || isActiveEnrollment(courseId);
      // Server-only writes (Admin SDK bypasses rules)
      allow create, update, delete: if false;

      // --- PHASE-2: COURSE STREAM (server-authoritative writes) ---
      match /stream/{postId} {
        allow read: if isStaff() || isActiveEnrollment(courseId);
        allow create, update, delete: if false;
      }

      // --- PHASE-2: ASSIGNMENTS + SUBMISSIONS (server-authoritative writes) ---
      match /assignments/{assignmentId} {
        allow read: if isStaff() || isActiveEnrollment(courseId);
        allow create, update, delete: if false;

        match /submissions/{userId} {
          allow read: if isStaff() || isInstructor(courseId) || userId == request.auth.uid;
          allow create, update, delete: if false;
        }
      }

      // --- PHASE-2: TESTS (server-authoritative writes) ---
      match /tests/{testId} {
        allow read: if isStaff() || isActiveEnrollment(courseId);
        allow create, update, delete: if false;

        // Secure content: instructors/staff only
        match /versions/{versionId} {
          // Phase-2 security: version content includes answer keys; clients must never read.
          // Only serverless functions (Admin SDK) may access versions.
          allow read: if false;
          allow create, update, delete: if false;
        }

        // Attempts: student can read their own attempt; instructors can read all
        match /attempts/{attemptId} {
          allow read: if isStaff() || isInstructor(courseId) || (isAuthenticated() && ('userId' in resource.data) && resource.data.userId == request.auth.uid);
          allow create, update, delete: if false;
        }
      }

      // --- PHASE-2: GRADES + GRADEBOOK (server-authoritative writes) ---
      match /grades/{gradeId} {
        // Students may only read their own grades while actively enrolled.
        allow read: if isStaff()
          || isInstructor(courseId)
          || (isActiveEnrollment(courseId)
            && isAuthenticated()
            && ('studentId' in resource.data)
            && resource.data.studentId == request.auth.uid);
        allow create, update, delete: if false;
      }

      match /gradebook/{studentId} {
        // Students may only read their own gradebook while actively enrolled.
        allow read: if isStaff()
          || isInstructor(courseId)
          || (isActiveEnrollment(courseId) && studentId == request.auth.uid);
        allow create, update, delete: if false;
      }

      match /enrollments/{enrolledUserId} {
        allow read: if isStaff() || enrolledUserId == request.auth.uid || isInstructor(courseId);
        allow create, update, delete: if false;
      }
    }

    // --- PHASE-2: DOMAIN EVENTS (append-only, server-authoritative writes) ---
    match /domainEvents/{eventId} {
      allow read: if isAdmin() || isPlatformInstructor();
      allow create, update, delete: if false;
    }

    // Canonical events collection (course-scoped visibility)
    match /events/{eventId} {
      // Students should consume events via userCalendars feed.
      // Canonical events are reserved for staff/instructors (for management/edit workflows).
      allow read: if isStaff()
        || (('courseId' in resource.data) && isInstructor(resource.data.courseId))
        || (('createdBy' in resource.data) && resource.data.createdBy == request.auth.uid);
      allow create, update, delete: if false;
    }

    // Per-user denormalized calendar feed (dashboard-friendly, no joins)
    match /userCalendars/{userId}/events/{eventId} {
      allow read: if isStaff() || userId == request.auth.uid;
      allow create, update, delete: if false;
    }

    // USER-SCOPED TO-DO + HABITS (private)
    match /users/{userId}/todoItems/{todoId} {
      allow read: if isOwner(userId);

      allow create: if isOwner(userId)
                    && isProfileComplete()
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time;

      allow update: if isOwner(userId)
                    && isProfileComplete()
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time;

      allow delete: if isOwner(userId) && isProfileComplete();
    }

    match /users/{userId}/habits/{habitId} {
      allow read: if isOwner(userId);

      allow create: if isOwner(userId)
                    && isProfileComplete()
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time;

      allow update: if isOwner(userId)
                    && isProfileComplete()
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time;

      allow delete: if isOwner(userId) && isProfileComplete();
    }

    // LEADERBOARD COLLECTION (Public subset of user data for leaderboard)
    match /leaderboard/{userId} {
      // Anyone authenticated can read leaderboard entries (contains only public data)
      allow read: if isAuthenticated();
      // Only the user can write their own leaderboard entry (via client SDK or Cloud Functions)
      allow create: if isValidLeaderboardWrite(request.resource.data, {}, userId);
      allow update: if isValidLeaderboardWrite(request.resource.data, resource.data, userId);
      allow delete: if isAdmin();
    }

    // RESOURCES COLLECTION
    match /resources/{resourceId} {
      // Public can read APPROVED resources.
      // Pending/rejected remain visible only to staff or the owner.
      // Back-compat: if status doesn't exist, treat as approved.
      allow read: if (
        !('status' in resource.data) ||
        resource.data.status == 'approved'
      ) || (
        isAuthenticated() && (
          isMod() ||
          (('ownerId' in resource.data) && resource.data.ownerId == request.auth.uid)
        )
      );
      
      // CREATE: Any authenticated user can submit a pending resource.
      // Admins may create approved resources.
      allow create: if !phase1ServerlessOnly()
            && isAuthenticated()
            && isProfileComplete()
                    && request.resource.data.ownerId == request.auth.uid
                    && isValidResource(request.resource.data)
                    && canSetModeratedStatus(request.resource.data)
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time
                    && !('isAdmin' in request.resource.data || 'role' in request.resource.data);

      // UPDATE: Admins can update anything (within validation). Owners can update their own pending resources.
      allow update: if !phase1ServerlessOnly()
                    && isProfileComplete()
                    && (
                      isMod() ||
                      (isAuthenticated()
                        && ('ownerId' in resource.data)
                        && resource.data.ownerId == request.auth.uid
                        && resource.data.status == 'pending'
                        && request.resource.data.status == 'pending'
                      )
                    )
                    && isValidResource(request.resource.data)
                    && canSetModeratedStatus(request.resource.data)
                    && request.resource.data.ownerId == resource.data.ownerId
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time
                    && !('isAdmin' in request.resource.data || 'role' in request.resource.data);

      // DELETE: Admins can delete any resource. Owners can delete their pending resources.
      allow delete: if !phase1ServerlessOnly()
                    && isProfileComplete()
                    && (isMod() || (
                      isAuthenticated()
                      && ('ownerId' in resource.data)
                      && resource.data.ownerId == request.auth.uid
                      && resource.data.status == 'pending'
                    ));
    }

    // RUNTIME CONFIG FLAGS
    match /config/phase1 {
      allow read: if true;
      allow write: if false;
    }

    // TO-DO ITEMS (private per-user)
    match /todoItems/{todoId} {
      allow read: if isAuthenticated() && resource.data.uid == request.auth.uid;

      allow create: if isAuthenticated()
                    && isProfileComplete()
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time;

      allow update: if isAuthenticated()
                    && isProfileComplete()
                    && resource.data.uid == request.auth.uid
                    && request.resource.data.uid == resource.data.uid
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time;

      allow delete: if isAuthenticated() && isProfileComplete() && resource.data.uid == request.auth.uid;
    }

    // HABITS (private per-user)
    match /habits/{habitId} {
      allow read: if isAuthenticated() && resource.data.uid == request.auth.uid;

      allow create: if isAuthenticated()
                    && isProfileComplete()
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time;

      allow update: if isAuthenticated()
                    && isProfileComplete()
                    && resource.data.uid == request.auth.uid
                    && request.resource.data.uid == resource.data.uid
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time;

      allow delete: if isAuthenticated() && isProfileComplete() && resource.data.uid == request.auth.uid;
    }

    // INTERACTIONS COLLECTION (private per-user analytics)
    match /interactions/{interactionId} {
      allow create: if isAuthenticated()
                    && isProfileComplete()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.timestamp == request.time;

      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if isAuthenticated() && isProfileComplete() && resource.data.userId == request.auth.uid;
    }

    // QUIZZES COLLECTION
    match /quizzes/{quizId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated()
                    && isProfileComplete()
                    && request.resource.data.createdBy == request.auth.uid
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.title is string
                    && request.resource.data.title.size() > 0
                    && request.resource.data.title.size() <= 200
                    && request.resource.data.subject is string
                    && request.resource.data.subject.size() > 0
                    && request.resource.data.subject.size() <= 200
                    && request.resource.data.topic is string
                    && request.resource.data.topic.size() > 0
                    && request.resource.data.topic.size() <= 200
                    && request.resource.data.difficulty in ['easy', 'medium', 'hard']
                    && request.resource.data.questions is list
                    && request.resource.data.questions.size() > 0
                    && request.resource.data.questions.size() <= 50;

      // Allow owner or admin to update/delete quizzes
      allow update, delete: if isAdmin() || (
        isAuthenticated()
        && isProfileComplete()
        && resource.data.createdBy == request.auth.uid
      );
    }

    // QUIZ ATTEMPTS COLLECTION
    match /quizAttempts/{attemptId} {
      allow read: if isAdmin() || (
        isAuthenticated()
        && resource.data.userId == request.auth.uid
      );

      allow create: if isAuthenticated()
                    && isProfileComplete()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.completedAt == request.time
                    && request.resource.data.quizId is string
                    && request.resource.data.quizId.size() > 0
                    && request.resource.data.score is int
                    && request.resource.data.score >= 0
                    && request.resource.data.totalQuestions is int
                    && request.resource.data.totalQuestions > 0
                    && request.resource.data.totalQuestions <= 200
                    && request.resource.data.score <= request.resource.data.totalQuestions
                    && request.resource.data.timeSpent is int
                    && request.resource.data.timeSpent >= 0
                    && request.resource.data.timeSpent <= 60 * 60 * 6
                    && request.resource.data.answers is map;

      // Attempts are immutable for users after submission.
      allow update, delete: if isAdmin();
    }

    // STUDY GROUPS COLLECTION
    match /studyGroups/{groupId} {
      // Discord-style: approved public groups are readable by all authenticated users (within allowed years).
      // Private groups are readable by members. Admin can read all.
      allow read: if isAuthenticated() && (
        isAdmin()
        || request.auth.uid in resource.data.members
        || (!resource.data.isPrivate && isAllowedYear(resource.data))
      );

      // Groups are created by admin approval (client-admin or server).
      allow create: if isAdmin();

      // Admins/group-admins can update; members can self-join/leave (members field only) for public groups.
      allow update: if isAuthenticated() && (
        (isAdmin() && (!phase1ServerlessOnly() || (
          request.resource.data.members == resource.data.members
          && request.resource.data.admins == resource.data.admins
        )))
        || (request.auth.uid in resource.data.admins && (!phase1ServerlessOnly() || (
          request.resource.data.members == resource.data.members
          && request.resource.data.admins == resource.data.admins
        )))
        || (
          // Self-join
          !phase1ServerlessOnly()
          && !resource.data.isPrivate
          && isAllowedYear(resource.data)
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['members'])
          && request.resource.data.members.size() == resource.data.members.size() + 1
          && request.resource.data.members.size() <= (('maxMembers' in resource.data) ? resource.data.maxMembers : 200)
          && request.resource.data.members.hasAll(resource.data.members)
          && request.auth.uid in request.resource.data.members
          && !(request.auth.uid in resource.data.members)
        )
        || (
          // Self-leave
          !phase1ServerlessOnly()
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['members'])
          && request.resource.data.members.size() == resource.data.members.size() - 1
          && resource.data.members.hasAll(request.resource.data.members)
          && request.auth.uid in resource.data.members
          && !(request.auth.uid in request.resource.data.members)
        )
      );

      allow delete: if isAuthenticated() && (isAdmin() || request.auth.uid in resource.data.admins);
    }

    // MESSAGES COLLECTION (subcollection of study groups)
    match /studyGroups/{groupId}/messages/{messageId} {
      // Members can read messages in their groups
      allow read: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members;
      
      // Members can create messages in their groups
      allow create: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members &&
                    isValidMessageCreate(request.resource.data, groupId);
      
      // Only message sender can update their own messages
      allow update: if isAuthenticated() && request.auth.uid == resource.data.senderId
                    && isValidMessageUpdate(request.resource.data, resource.data);
      
      // Message sender or group admin can delete
      allow delete: if isAuthenticated() && (
        request.auth.uid == resource.data.senderId ||
        request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.admins
      );
    }

    // SESSIONS COLLECTION (subcollection of study groups)
    match /studyGroups/{groupId}/sessions/{sessionId} {
      // Members can read sessions in their groups
      allow read: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members;
      
      // Group admins can create sessions
      allow create: if !phase1ServerlessOnly()
            && isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.admins &&
                    request.resource.data.createdBy == request.auth.uid;
      
      // Group admins or session creator can update
      allow update: if !phase1ServerlessOnly()
                    && isAuthenticated() && (
        request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.admins ||
        request.auth.uid == resource.data.createdBy
      );
      
      // Group admins or session creator can delete
      allow delete: if !phase1ServerlessOnly()
                    && isAuthenticated() && (
        request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.admins ||
        request.auth.uid == resource.data.createdBy
      );
    }

    // COLLABORATIVE NOTES COLLECTION (subcollection of study groups)
    match /studyGroups/{groupId}/notes/{noteId} {
      // Members can read notes in their groups
      allow read: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members;
      
      // Members can create notes in their groups
      allow create: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members &&
                    isValidNoteCreate(request.resource.data, groupId);
      
      // Members can update notes (collaborative editing)
      allow update: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members &&
                    request.resource.data.lastEditedBy == request.auth.uid
                    && isValidNoteUpdate(request.resource.data, resource.data);
      
      // Note creator or group admin can delete
      allow delete: if isAuthenticated() && (
        request.auth.uid == resource.data.createdBy ||
        request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.admins
      );
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}