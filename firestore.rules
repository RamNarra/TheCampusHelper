rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- HELPER FUNCTIONS ---

    function isAuthenticated() {
      return request.auth != null;
    }

    function isBootstrapAdmin() {
      // Bootstrap path for the very first admin: either a custom claim, or a strict allowlist.
      // NOTE: Update this allowlist for your project.
      return isAuthenticated() && (
        request.auth.token.admin == true ||
        request.auth.token.email in ["admin@thecampushelper.com", "ramcharannarra8@gmail.com"]
      );
    }

    function myUserDoc() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function myRole() {
      return (isAuthenticated() && exists(/databases/$(database)/documents/users/$(request.auth.uid)) && ('role' in myUserDoc()))
        ? myUserDoc().role
        : 'user';
    }

    function isAdmin() {
      return isAuthenticated() && (isBootstrapAdmin() || myRole() == 'admin');
    }

    function isMod() {
      return isAuthenticated() && (isAdmin() || myRole() == 'mod');
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Validates resource structure (allows extra keys)
    function isValidResource(data) {
      return data.keys().hasAll(['title', 'subject', 'type', 'downloadUrl', 'ownerId', 'status', 'createdAt', 'updatedAt'])
             && data.title is string && data.title.size() > 3 && data.title.size() < 200
             && data.subject is string && data.subject.size() > 0 && data.subject.size() < 200
             && data.type is string && data.type.size() > 0 && data.type.size() < 50
             && data.downloadUrl is string && data.downloadUrl.size() > 5 && data.downloadUrl.size() < 2000
             && data.ownerId is string
             && (data.status == 'pending' || data.status == 'approved' || data.status == 'rejected');
    }

    function canSetModeratedStatus(data) {
      // Users can only submit pending resources.
      // Mods/Admins can approve/reject.
      return data.status == 'pending' || ((data.status == 'approved' || data.status == 'rejected') && isMod());
    }

    // Prevents privilege escalation on user profiles
    function roleIsAllowedOnCreate(data) {
      // Normal users may only create with role 'user' (or omit role).
      // Bootstrap admin may create their own profile with role 'admin'.
      return !("role" in data)
        || data.role == 'user'
        || (data.role == 'admin' && isBootstrapAdmin());
    }

    function roleIsSafeOnOwnerUpdate(newData, currentData) {
      // Owners cannot change role/disabled.
      // Back-compat: if role is missing, owner may set role='user' only.
      let roleOk = !("role" in newData)
        || ("role" in currentData && newData.role == currentData.role)
        || (!("role" in currentData) && newData.role == 'user');

      let disabledOk = !("disabled" in newData)
        || ("disabled" in currentData && newData.disabled == currentData.disabled);

      return roleOk && disabledOk;
    }

    // --- COLLECTION RULES ---

    // USERS COLLECTION
    match /users/{userId} {
      // Owner can read their profile; staff can read for moderation/admin.
      allow read: if isOwner(userId) || isMod();

      allow create: if isOwner(userId)
                    && roleIsAllowedOnCreate(request.resource.data);

      // Owner can update their own profile (no privilege escalation).
      allow update: if (
                      isOwner(userId)
                      && roleIsSafeOnOwnerUpdate(request.resource.data, resource.data)
                    )
                    || (
                      // Admin can manage roles/disable for any user.
                      isAdmin()
                      && (
                        !("role" in request.resource.data) || (request.resource.data.role in ['user','mod','admin'])
                      )
                    );

      allow delete: if isAdmin();
    }

    // USER-SCOPED TO-DO + HABITS (private)
    match /users/{userId}/todoItems/{todoId} {
      allow read: if isOwner(userId);

      allow create: if isOwner(userId)
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time;

      allow update: if isOwner(userId)
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time;

      allow delete: if isOwner(userId);
    }

    match /users/{userId}/habits/{habitId} {
      allow read: if isOwner(userId);

      allow create: if isOwner(userId)
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time;

      allow update: if isOwner(userId)
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time;

      allow delete: if isOwner(userId);
    }

    // LEADERBOARD COLLECTION (Public subset of user data for leaderboard)
    match /leaderboard/{userId} {
      // Anyone authenticated can read leaderboard entries (contains only public data)
      allow read: if isAuthenticated();
      // Only the user can write their own leaderboard entry (via client SDK or Cloud Functions)
      allow write: if isOwner(userId);
    }

    // RESOURCES COLLECTION
    match /resources/{resourceId} {
      // Public can read APPROVED resources.
      // Pending/rejected remain visible only to staff or the owner.
      // Back-compat: if status doesn't exist, treat as approved.
      allow read: if (
        !('status' in resource.data) ||
        resource.data.status == 'approved'
      ) || (
        isAuthenticated() && (
          isMod() ||
          (('ownerId' in resource.data) && resource.data.ownerId == request.auth.uid)
        )
      );
      
      // CREATE: Any authenticated user can submit a pending resource.
      // Admins may create approved resources.
      allow create: if isAuthenticated()
                    && request.resource.data.ownerId == request.auth.uid
                    && isValidResource(request.resource.data)
                    && canSetModeratedStatus(request.resource.data)
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time
                    && !('isAdmin' in request.resource.data || 'role' in request.resource.data);

      // UPDATE: Admins can update anything (within validation). Owners can update their own pending resources.
      allow update: if (
                      isMod() ||
                      (isAuthenticated()
                        && ('ownerId' in resource.data)
                        && resource.data.ownerId == request.auth.uid
                        && resource.data.status == 'pending'
                        && request.resource.data.status == 'pending'
                      )
                    )
                    && isValidResource(request.resource.data)
                    && canSetModeratedStatus(request.resource.data)
                    && request.resource.data.ownerId == resource.data.ownerId
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time
                    && !('isAdmin' in request.resource.data || 'role' in request.resource.data);

      // DELETE: Admins can delete any resource. Owners can delete their pending resources.
      allow delete: if isMod() || (
                      isAuthenticated()
                      && ('ownerId' in resource.data)
                      && resource.data.ownerId == request.auth.uid
                      && resource.data.status == 'pending'
                    );
    }

    // TO-DO ITEMS (private per-user)
    match /todoItems/{todoId} {
      allow read: if isAuthenticated() && resource.data.uid == request.auth.uid;

      allow create: if isAuthenticated()
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time;

      allow update: if isAuthenticated()
                    && resource.data.uid == request.auth.uid
                    && request.resource.data.uid == resource.data.uid
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time;

      allow delete: if isAuthenticated() && resource.data.uid == request.auth.uid;
    }

    // HABITS (private per-user)
    match /habits/{habitId} {
      allow read: if isAuthenticated() && resource.data.uid == request.auth.uid;

      allow create: if isAuthenticated()
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.createdAt == request.time
                    && request.resource.data.updatedAt == request.time;

      allow update: if isAuthenticated()
                    && resource.data.uid == request.auth.uid
                    && request.resource.data.uid == resource.data.uid
                    && request.resource.data.createdAt == resource.data.createdAt
                    && request.resource.data.updatedAt == request.time;

      allow delete: if isAuthenticated() && resource.data.uid == request.auth.uid;
    }

    // INTERACTIONS COLLECTION (private per-user analytics)
    match /interactions/{interactionId} {
      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.timestamp == request.time;

      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow update: if false;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // QUIZZES COLLECTION
    match /quizzes/{quizId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated()
                    && request.resource.data.createdBy == request.auth.uid
                    && request.resource.data.createdAt == request.time;

      // Allow owner or admin to update/delete quizzes
      allow update, delete: if isAdmin() || (
        isAuthenticated()
        && resource.data.createdBy == request.auth.uid
      );
    }

    // QUIZ ATTEMPTS COLLECTION
    match /quizAttempts/{attemptId} {
      allow read: if isAdmin() || (
        isAuthenticated()
        && resource.data.userId == request.auth.uid
      );

      allow create: if isAuthenticated()
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.completedAt == request.time;

      allow update, delete: if isAdmin() || (
        isAuthenticated()
        && resource.data.userId == request.auth.uid
      );
    }

    // STUDY GROUPS COLLECTION
    match /studyGroups/{groupId} {
      // Anyone authenticated can read public groups, members can read their private groups
      allow read: if isAuthenticated() && (
        !resource.data.isPrivate || 
        request.auth.uid in resource.data.members
      );
      
      // Any authenticated user can create a group
      allow create: if isAuthenticated()
                    && request.resource.data.createdBy == request.auth.uid
                    && request.auth.uid in request.resource.data.members
                    && request.auth.uid in request.resource.data.admins;
      
      // Only group admins can update
      allow update: if isAuthenticated() && request.auth.uid in resource.data.admins;
      
      // Only group admins can delete
      allow delete: if isAuthenticated() && request.auth.uid in resource.data.admins;
    }

    // MESSAGES COLLECTION (subcollection of study groups)
    match /studyGroups/{groupId}/messages/{messageId} {
      // Members can read messages in their groups
      allow read: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members;
      
      // Members can create messages in their groups
      allow create: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members &&
                    request.resource.data.senderId == request.auth.uid;
      
      // Only message sender can update their own messages
      allow update: if isAuthenticated() && request.auth.uid == resource.data.senderId;
      
      // Message sender or group admin can delete
      allow delete: if isAuthenticated() && (
        request.auth.uid == resource.data.senderId ||
        request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.admins
      );
    }

    // SESSIONS COLLECTION (subcollection of study groups)
    match /studyGroups/{groupId}/sessions/{sessionId} {
      // Members can read sessions in their groups
      allow read: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members;
      
      // Group admins can create sessions
      allow create: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.admins &&
                    request.resource.data.createdBy == request.auth.uid;
      
      // Group admins or session creator can update
      allow update: if isAuthenticated() && (
        request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.admins ||
        request.auth.uid == resource.data.createdBy
      );
      
      // Group admins or session creator can delete
      allow delete: if isAuthenticated() && (
        request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.admins ||
        request.auth.uid == resource.data.createdBy
      );
    }

    // COLLABORATIVE NOTES COLLECTION (subcollection of study groups)
    match /studyGroups/{groupId}/notes/{noteId} {
      // Members can read notes in their groups
      allow read: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members;
      
      // Members can create notes in their groups
      allow create: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members &&
                    request.resource.data.createdBy == request.auth.uid;
      
      // Members can update notes (collaborative editing)
      allow update: if isAuthenticated() && 
                    request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.members &&
                    request.resource.data.lastEditedBy == request.auth.uid;
      
      // Note creator or group admin can delete
      allow delete: if isAuthenticated() && (
        request.auth.uid == resource.data.createdBy ||
        request.auth.uid in get(/databases/$(database)/documents/studyGroups/$(groupId)).data.admins
      );
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}